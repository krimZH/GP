#Note about IO
[TOC]
##从TCP/IP开始
####TCP 缓冲区
<p>首先，对于TCP通信来说，每个TCP Socket在内核中都有一个发送缓冲区和一个接受缓冲区，TCP的全双工工作模式及TCP的滑动窗口便依赖于这两个独立的Buffer及此Buffer的填充状态。接受缓冲区会把数据缓存入内核，若应用进程一致没有调用Socket的read方法进行读取的话，则此数据会一直被缓存在接收缓冲区内。不管进程是否读取Socket，对端发来的数据都会进过内核接受并且缓存到接受缓冲区中。read所做的工作，就是把内存接收缓冲区中的数据复制到应用进程的Buffer里，仅此而已。进程调用Buffer的send方法发送数据的时候，最简单的情况，也是一般的情况下，是将数据从应用层用户的Buffer中复制到Socket的内核发送缓冲区，然后send便向上返回，也就是说send返回时，数据并不一定会发送到对端。UDP因为不需要确定连接是否存在，所以没有发送缓冲区，只有接收缓冲区。
</p>
####TCP 滑动窗口
<p>滑动窗口是TCP连接在三次握手阶段，由接收端定义的。因为TCP需要控流和保证数据的可靠性，所以在发送端和接受端都有一个缓冲区，滑动窗口便建立在缓冲区之上。可以把滑动窗口想象成一个数组。
<p>
在发送端，这个数组被分为四个部分：1.已经发送且确认的，2.已经发送但没有确认的，3.没有发送但是需要发送的，4.没有发送且因为接收方没有足够的缓冲区而不允许发送的。其中滑动窗口的大小就是2+3的大小
</p><p>
在接受端，被分为三个部分，1.接收到了数据但是没有被上层应用read的，2.接受到了数据但是没有进行ACK的，3.可以接受数据的空间。
</p>

<p>得一下为啥接收端会的滑动窗口会有2这个部分。打个比方，发送端要发送一个消息，并拆成4个报文发送，他们的序列号分别为：seq1,seq2,seq3,seq4，接收端收到了seq1,seq2,seq4，发现少了seq3，于是接收端返回ACK：收到了seq1,seq2;并保留了seq4，创建了一个预留给seq3的空间，等待发送端重新发送，发送端收到了ACK，并把seq1,seq2的那部分数据从滑动窗口中踢出(指针向右移动),等到timeout了，重新发送seq3,seq4，这时，如果接收端收到了，皆大欢喜，如果没有收到，则会将之前保存的预留位置和seq4一起丢掉</p>
##BIO
<p>BIO:阻塞IO</p>
<p>优点：当只有少量TCP连接通信，双方都非常快地传输数据，此时这种模型性能最高</p>
<p>缺点：使用一个socket绑定一个线程，处理一个客户端的请求需要一个线程，当需要处理的客户端很多时，会创建很多线程，而线程的创建和销毁是很占资源的，当客户端多时，这会导致服务器性能的急剧下降，更糟的是可能会挂掉</p>
##NIO
<p>NIO:非阻塞IO</p>
<p>优点：</p>